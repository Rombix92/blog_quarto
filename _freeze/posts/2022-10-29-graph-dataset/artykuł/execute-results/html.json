{
  "hash": "9c5ad20bc175a4b94e93b922e538850e",
  "result": {
    "markdown": "---\ntitle: \"DGL graph datastructure\"\ncategories: [\"DGL\"]\ntags: [\"DGL\", \"graph\", \"graph datastructure\", \"compressed sparsed matrix\"]\ntoc: TRUE\n---\n\n\n\n\n\n\n\n\n\n\n# Creating Graph data\n\nVery simple example below\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Each value of the dictionary is a list of edge tuples.\n# Nodes are integer IDs starting from zero. Nodes IDs of different types have\n# separate countings.\nimport torch\nimport dgl\n## /Users/lrabalski1/miniforge3/envs/tensorflow_mac/lib/python3.8/site-packages/scipy/__init__.py:146: UserWarning: A NumPy version >=1.16.5 and <1.23.0 is required for this version of SciPy (detected version 1.23.4\n##   warnings.warn(f\"A NumPy version >={np_minversion} and <{np_maxversion}\"\nratings = dgl.heterograph(\n    {('user', '+1', 'movie') : [(0, 0), (0, 1), (1, 0)],\n     ('user', '-1', 'movie') : [(2, 1)]})\nratings\n\n## Graph(num_nodes={'movie': 2, 'user': 3},\n##       num_edges={('user', '+1', 'movie'): 3, ('user', '-1', 'movie'): 1},\n##       metagraph=[('user', 'movie', '+1'), ('user', 'movie', '-1')])\n```\n:::\n\n\n## saving graph\n\nIn order to save graph as object, very convenient method is to use `pickle.`\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pickle\n\noutput_file = 'builded_graph.pkl'\ndirectory = 'input/'\nwith open(directory + output_file, 'rb') as f:\n    g = pickle.load(f)\n\n\n#loading saved graph\nwith open(directory  + output_file, 'rb') as f:\n    sp_matrix = pickle.load(f)\n\n```\n:::\n\n\nTo create a more realistic heterograph let's use the ACM dataset. \\## Graphs Dataset can be downloaded from [here](https://www.aminer.org/citation). It's stored in mat (matrix) object. Within which we can find object/matrices stored in a `compresed sparsed` format. More about further.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport scipy.io\nimport urllib.request\n\ndata = scipy.io.loadmat(data_file_path+'ACM.mat')\n\n```\n:::\n\n\n## compresed sparsed matrix\n\nMany different ways to store `sparsed matrices` may be find in scipy [documentation](https://docs.scipy.org/doc/scipy/reference/sparse.html).\n\nFor us most important will be `csr_matrix` and `csc_matrix`.\n\nCSC format is almost identical, except that values are indexed first by column with a column-major order. Usually, the CSC is used when there are more rows than columns. On the contrary, the CSR works better for a 'wide' format. So, her is taking CSR as an example here.\n\nBelow short example how `sparsed matrices` can be handle with `scipy` package.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nfrom scipy.sparse import csr_matrix, csc_matrix\narr = np.array([[0, 0, 0], [0, 0, 1], [1, 2, 0]])\n\narr_csr = csr_matrix(arr)\narr_csc = csc_matrix(arr)\n\nprint(type(arr_csr))\n## <class 'scipy.sparse.csr.csr_matrix'>\nprint(type(arr_csc))\n\n# `CSC` format is almost identical, except that values are indexed first by column with a column-major order. Usually, the `CSC` is used when there are more rows than columns. On the contrary, the `CSR` works better for a ‘wide’ format. So, her is taking CSR as an example here\n## <class 'scipy.sparse.csc.csc_matrix'>\nprint(arr_csr)\n##   (1, 2)\t1\n##   (2, 0)\t1\n##   (2, 1)\t2\nprint(arr_csc)\n\n# however in order to get access ti those indexes need to use method to_coo.\n##   (2, 0)\t1\n##   (2, 1)\t2\n##   (1, 2)\t1\narr_csr.tocoo().row\n## array([1, 2, 2], dtype=int32)\narr_csr.tocoo().col\n\n#Viewing stored data (not the zero items) with the data property\n## array([2, 0, 1], dtype=int32)\nprint(arr_csr.data)\n## [1 1 2]\nprint(arr_csc.data)\n\n#Counting nonzeros with the count_nonzero() method:\n## [1 2 1]\nprint(arr_csr.count_nonzero())\n## 3\nprint(arr_csc.count_nonzero)\n## <bound method _data_matrix.count_nonzero of <3x3 sparse matrix of type '<class 'numpy.int64'>'\n## \twith 3 stored elements in Compressed Sparse Column format>>\nprint(arr_csr.toarray())\n## [[0 0 0]\n##  [0 0 1]\n##  [1 2 0]]\nprint(arr_csc.todense())\n\n## [[0 0 0]\n##  [0 0 1]\n##  [1 2 0]]\n```\n:::\n\n\n## SP matrix methods\n\n### bipartite_from_scipy\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport scipy.sparse as sp\n\nsp_matrix = data['PvsA']\nprint(type(sp_matrix))\n## <class 'scipy.sparse.csc.csc_matrix'>\nprint('#Papers:', sp_matrix.shape[0])\n## #Papers: 12499\nprint('#Authors:',sp_matrix.shape[1])\n## #Authors: 17431\nprint('#Links:', sp_matrix.nnz)\n\n# ways of populating graph with coo_matrix\n## #Links: 37055\npp_g = dgl.bipartite_from_scipy(sp_matrix, utype='paper', etype='written-by', vtype='author')\n\npp_g.is_homogeneous\n## False\nprint(pp_g.number_of_nodes())\n## 29930\nprint(pp_g.number_of_edges())\n## 37055\nprint(pp_g.successors(3))\n## tensor([ 4295, 13161])\nprint('Node types:', pp_g.ntypes)\n## Node types: ['paper', 'author']\nprint('Edge types:', pp_g.etypes)\n## Edge types: ['written-by']\nprint('Canonical edge types:', pp_g.canonical_etypes)\n## Canonical edge types: [('paper', 'written-by', 'author')]\n```\n:::\n\n\nIn order to visualize the interactions (edges) between nodes let use following function.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pygraphviz as pgv\ndef plot_graph(nxg, plot_name):\n    ag = pgv.AGraph(strict=False, directed=True)\n    for u, v, k in nxg.edges(keys=True):\n        ag.add_edge(u, v, label=k)\n    ag.layout('dot')\n    ag.draw(plot_name+'.png')\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nplot_graph(nxg=pp_g.metagraph(),plot_name='simple_graph')\n```\n:::\n\n\n![](simple_graph.png)\n\n### heterograph\n\nUsing ACM dataset\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport torch\n\n# Unfortunately following code no longer works\nG = dgl.heterograph({\n        ('paper', 'written-by', 'author') : data['PvsA'],\n        ('author', 'writing', 'paper') : data['PvsA'].transpose(),\n        ('paper', 'citing', 'paper') : data['PvsP'],\n        ('paper', 'cited', 'paper') : data['PvsP'].transpose(),\n        ('paper', 'is-about', 'subject') : data['PvsL'],\n        ('subject', 'has', 'paper') : data['PvsL'].transpose(),\n    })\n\n# we need to a little bit tweak the code the get the same result as above.\n## Error in py_call_impl(callable, dots$args, dots$keywords): dgl._ffi.base.DGLError: dgl.heterograph no longer supports graph construction from a SciPy sparse matrix, use dgl.from_scipy instead.\nG = dgl.heterograph({\n        ('paper', 'written-by', 'author') : \n          (torch.tensor(data['PvsA'].tocoo().col),torch.tensor(data['PvsA'].tocoo().row )),\n         ('author', 'writing', 'paper') : \n           (torch.tensor(data['PvsA'].tocoo().row) ,torch.tensor(data['PvsA'].tocoo().col)),\n        ('paper', 'citing', 'paper') : \n          (torch.tensor(data['PvsP'].tocoo().col),torch.tensor(data['PvsP'].tocoo().row )),\n        ('paper', 'cited', 'paper') : \n          (torch.tensor(data['PvsP'].tocoo().row) ,torch.tensor(data['PvsP'].tocoo().col)),\n        ('paper', 'is-about', 'subject') : \n          (torch.tensor(data['PvsL'].tocoo().col),torch.tensor(data['PvsL'].tocoo().row )),\n        ('subject', 'has', 'paper') : \n          (torch.tensor(data['PvsL'].tocoo().row) ,torch.tensor(data['PvsL'].tocoo().col))\n    })\n  \nplot_graph(nxg=G.metagraph(),plot_name='more_complicated_graph')\n\n```\n:::\n\n\n![](more_complicated_graph.png)\n\n## pandas method\n\nOn [github repository](https://github.com/yoonjong12/pinsage/blob/main/builder.py) we can find a method allowing for building graphs using pandas dataphrame.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport sys\nsys.path.insert(1, repo_directory)\nfrom builder import PandasGraphBuilder\n## Error in py_call_impl(callable, dots$args, dots$keywords): ModuleNotFoundError: No module named 'builder'\nusers=pd.DataFrame(data=range(1,101), columns=['user_id'])\nproducts=pd.DataFrame(data=range(1,50), columns=['product_id'])\ninteractions=pd.DataFrame(data={\n  'user_id': np.random.choice(users.user_id,1000,replace=True),\n  'product_id' :np.random.choice(products.product_id,1000,replace=True)}\n  )\n\n\n\n\ngraph_builder = PandasGraphBuilder()\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'PandasGraphBuilder' is not defined\ngraph_builder.add_entities(users, 'user_id', 'user')\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'graph_builder' is not defined\ngraph_builder.add_entities(products, 'product_id', 'product')\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'graph_builder' is not defined\ngraph_builder.add_binary_relations(interactions, 'user_id','product_id', 'interaction')\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'graph_builder' is not defined\ngraph_builder.add_binary_relations(interactions, 'product_id','user_id', 'interaction-by')\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'graph_builder' is not defined\nprint('starting graph building')\n## starting graph building\ng = graph_builder.build()\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'graph_builder' is not defined\nplot_graph(nxg=g.metagraph(),plot_name='pandas_graph')\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'g' is not defined\n```\n:::\n\n\n![](pandas_graph.png)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}