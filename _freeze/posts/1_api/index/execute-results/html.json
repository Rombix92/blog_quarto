{
  "hash": "5cdb157c2901f15597690ef365530bce",
  "result": {
    "markdown": "---\ntitle-block-banner: true\nauthor: Łukasz Rąbalski\ntitle: API connections  \ndescription: Presentation how to connect to API with token authenthification using R and Python\nformat:\n  html:\n    toc: true\n    toc-location: left\n    number-sections: true\n    toc-depth: 3\n    embed-resources: true\ncategories: ['Python','R','API']\ntags: ['http']\neditor: source\nfig.height: 4\nout.width: '100%'\ninclude: TRUE  #prevents code and results from appearing in the finished file. R Markdown still runs the code in the chunk, and the results can be used by other chunks.\necho: TRUE  #echo = FALSE prevents code, but not the results from appearing in the finished file. This is a useful way to embed figures.\nwarning: FALSE\nmessage: FALSE\nerror: FALSE\ndraft: FALSE\n\n---\n\n\n::: white\n# TOC {.unnumbered}\n\n##### python {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(reticulate)\nmyenvs=conda_list()\nenvname=myenvs$name[4]\nuse_condaenv(envname, required = TRUE)\n\nSys.setenv(RETICULATE_PYTHON = \"/Users/lrabalski1/miniforge3/envs/everyday_use/bin/python\")\nreticulate::py_config()\n```\n:::\n\n\n##### authentification {.unnumbered}\n\n\n\n\n:::\n\n# R\n\n\n## POST method\n\nKnowledge based on\n\n[documentation of httr](https://cran.r-project.org/web/packages/httr/vignettes/quickstart.html)\n\n[tutorial how to authorized connections with token](https://developers.refinitiv.com/en/article-catalog/article/tick-history-in-r-language-part-1)\n\n[HTTP statuses](https://www.flickr.com/photos/girliemac/sets/72157628409467125)\n\nBelow I present how to validly connect to API and receive output using POST method. I am showing different ways of how json could be prepared out of which only 1 is valid and allows for receiving expected results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"httr\")\nlibrary(\"jsonlite\")\n\n\n\nb_json_not_valid<-paste0(\"{'model':'agent','content':'/\\r\\n//\\r\\n//\\r\\n/putin/\\r\\n/dsfdfds pozdrawiam Janusz','sender': 'januszeky'}\")\n\nb_list=list(model= \"agent\",content = \"/\\r\\n//\\r\\n//\\r\\n/putin/\\r\\n/dsfdfds pozdrawiam Janusz\",sender= \"januszeky\")\nb_temp <- unbox(data.frame(b_list))\nb_jons <- toJSON(b_temp, pretty = TRUE)\n\n\nr<- httr::POST(url,\n                add_headers(Authorization = auth),\n                #content_type_json(),\n                content_type(\"application/json\"),\n                body = b_json_not_valid,\n                encode = \"json\"\n               )\nprint('json like below will result with \"Internal Server Error\"')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"json like below will result with \\\"Internal Server Error\\\"\"\n```\n:::\n\n```{.r .cell-code}\nprint(class(b_json_not_valid))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nprint(b_json_not_valid)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"{'model':'agent','content':'/\\r\\n//\\r\\n//\\r\\n/putin/\\r\\n/dsfdfds pozdrawiam Janusz','sender': 'januszeky'}\"\n```\n:::\n\n```{.r .cell-code}\nhttr::content(r) # to extract content from the response\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$error\n$error$message\n[1] \"Internal Server Error\"\n```\n:::\n\n```{.r .cell-code}\nr<- httr::POST(url,\n                add_headers(Authorization = auth),\n                #content_type_json(),\n                content_type(\"application/json\"),\n                body = toJSON(b_list),\n                encode = \"json\"\n               )\n\nprint('json like below will more informative error, suggesting that argument should be string not list\"')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"json like below will more informative error, suggesting that argument should be string not list\\\"\"\n```\n:::\n\n```{.r .cell-code}\nprint(class(toJSON(b_list)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"json\"\n```\n:::\n\n```{.r .cell-code}\nprint(toJSON(b_list))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\"model\":[\"agent\"],\"content\":[\"/\\r\\n//\\r\\n//\\r\\n/putin/\\r\\n/dsfdfds pozdrawiam Janusz\"],\"sender\":[\"januszeky\"]} \n```\n:::\n\n```{.r .cell-code}\nhttr::content(r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$error\n$error$errors\n$error$errors$model\n$error$errors$model[[1]]\n[1] \"This value should be of type string.\"\n\n\n$error$errors$content\n$error$errors$content[[1]]\n[1] \"This value should be of type string.\"\n\n\n$error$errors$sender\n$error$errors$sender[[1]]\n[1] \"This value should be of type string.\"\n\n\n\n$error$message\n[1] \"Request is not valid\"\n```\n:::\n\n```{.r .cell-code}\ntictoc::tic()\nr <- httr::POST(url,\n           add_headers(Authorization = auth),\n           content_type(\"application/json\"),\n           body = b_jons,\n           content_type_json()\n           #encode = \"json\"\n           )\ntictoc::toc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.338 sec elapsed\n```\n:::\n\n```{.r .cell-code}\nprint('json like below will finally give positive result')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"json like below will finally give positive result\"\n```\n:::\n\n```{.r .cell-code}\nprint(class(b_jons))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"json\"\n```\n:::\n\n```{.r .cell-code}\nprint(b_jons)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n    \"model\": \"agent\",\n    \"content\": \"/\\r\\n//\\r\\n//\\r\\n/putin/\\r\\n/dsfdfds pozdrawiam Janusz\",\n    \"sender\": \"januszeky\"\n  } \n```\n:::\n\n```{.r .cell-code}\nhttr::content(r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$content\n[1] \" putin dsfdfds mail od januszeky\"\n```\n:::\n\n```{.r .cell-code}\nstop_for_status(r) #stop_for_status so that the function stops when there is an error.\n```\n:::\n\n\nABOVE last working methods is substitute for following HTTP request form:\n\n\n::: {.cell}\n\n```{.http .cell-code}\nPOST url\nContent-Type: application/json\nAuthorization: token_code\n\n{\n\"model\": \"agent\",\n\"content\" : \"/\\r\\n//\\r\\n//\\r\\n/putin/\\r\\n/dsfdfds pozdrawiam Janusz\",\n\"sender\": \"januszeky\"\n}\n>> path_to_save_file\n```\n:::\n\n\n\n## Free API to play with\n\nIf someone wants\n\n[url](https://api.stackexchange.com/docs)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- GET(\n  \"http://api.stackexchange.com\",\n  path = \"questions\",\n  query = list(\n    site = \"stackoverflow.com\",\n    tagged = \"r\"\n  )\n)\n\n\nstop_for_status(r)\n\n# Automatically parse the json output\nquestions <- content(r)\n# questions$items[[1]]$title\n# questions$items[[1]]$link\n```\n:::\n\n\n# Python\n\nThe same case solved in Python. Here it is less deceptive because json has json object in it's repertoire.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport requests\nimport json\njson_file =  {\"model\": \"agent\",\"content\" : \"/\\r\\n//\\r\\n//\\r\\n/putin/\\r\\n/dsfdfds pozdrawiam Janusz\",\"sender\": \"januszeky\"}\n\nurl=r.url\nauth=r.auth\n\nx = requests.post(url, json = json_file, headers={'Authorization': auth})\nprint(x.text)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\"content\":\" putin dsfdfds mail od januszeky\"}\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}