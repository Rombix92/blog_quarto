{
  "hash": "833946b227651886cbda51b026d7b632",
  "result": {
    "markdown": "---\ntitle-block-banner: true\nauthor: Łukasz Rąbalski\ntitle: \"Paralel processing with CPU\"\ndescription: Presentation of how different techniques of parralel processing in Python works\nformat:\n  html:\n    toc: true\n    toc-location: left\n    number-sections: true\n    toc-depth: 3\n    embed-resources: true\ncategories: ['Python','multiprocessing']\ntags: []\neditor: source\nfig.height: 4\nout.width: '100%'\ninclude: TRUE  #prevents code and results from appearing in the finished file. R Markdown still runs the code in the chunk, and the results can be used by other chunks.\necho: TRUE  #echo = FALSE prevents code, but not the results from appearing in the finished file. This is a useful way to embed figures.\nwarning: FALSE\nmessage: FALSE\nerror: FALSE\ndraft: TRUE\n\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(reticulate)\nmyenvs=conda_list()\nenvname=myenvs$name[4]\nuse_condaenv(envname, required = TRUE)\n\nSys.setenv(RETICULATE_PYTHON = \"/Users/lrabalski1/miniforge3/envs/everyday_use/bin/python\")\nreticulate::py_config()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npython:         /Users/lrabalski1/miniforge3/envs/everyday_use/bin/python\nlibpython:      /Users/lrabalski1/miniforge3/envs/everyday_use/lib/libpython3.8.dylib\npythonhome:     /Users/lrabalski1/miniforge3/envs/everyday_use:/Users/lrabalski1/miniforge3/envs/everyday_use\nversion:        3.8.12 | packaged by conda-forge | (default, Oct 12 2021, 21:21:17)  [Clang 11.1.0 ]\nnumpy:          /Users/lrabalski1/miniforge3/envs/everyday_use/lib/python3.8/site-packages/numpy\nnumpy_version:  1.21.4\n\nNOTE: Python version was forced by RETICULATE_PYTHON\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n\nimport time\nfrom time import sleep\nfrom random import random\nimport multiprocessing\nfrom multiprocessing import Pool\nfrom itertools import repeat\nimport numpy as np\n\n\nimport pandas as pd\nfrom datetime import datetime\n```\n:::\n\n\nTo check how different parallel processing techniques works I prepared function which looks liked that\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom analiza import map_function\n\nimport inspect\nprint(inspect.getsource(map_function))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndef map_function(combo):\n    pd_results_temp=pd.DataFrame(columns=['a','b','c','started'])\n    started = datetime.now()\n    a = combo[0]\n    b = combo[1]\n    c = combo[2]\n    pd_results_temp = pd_results_temp.append({'a':a,'b':b,'c':c,'started':started}, ignore_index=True)\n    sleep(b)\n    return pd_results_temp\n```\n:::\n:::\n\n\nIn case of multiporcessing functions it's good practice to keep function in saved files in order to import them later.\nSee https://bugs.python.org/issue25053. \nFor some reason Pool does not always work with objects not defined in an imported module. So you have to write your function into a different file and import the module.\n%% https://stackoverflow.com/questions/41385708/multiprocessing-example-giving-attributeerror %%\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\n\n\n\n\n\n# def map_function(combo):\n#     pd_results_temp=pd.DataFrame(columns=['a','b','c','started'])\n#     started = datetime.now()\n#     a = combo[0]\n#     b = combo[1]\n#     c = combo[2]\n#     pd_results_temp = pd_results_temp.append({'a':a,'b':b,'c':c,'started':started}, ignore_index=True)\n#     sleep(b)\n#     return pd_results_temp\n\n\n\n\ncombo = np.array([1,1,1], ndmin=2)\ncombo = np.append(combo,np.array([2,1,2], ndmin=2), axis=0)\ncombo = np.append(combo,np.array([3,0.5,3], ndmin=2), axis=0)\ncombo = np.append(combo,combo, axis=0)\ncombo = np.append(combo,combo, axis=0)\n\n\npd_results=pd.DataFrame(columns=['a','b','c','started'])\nprint(combo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1.  1.  1. ]\n [2.  1.  2. ]\n [3.  0.5 3. ]\n [1.  1.  1. ]\n [2.  1.  2. ]\n [3.  0.5 3. ]\n [1.  1.  1. ]\n [2.  1.  2. ]\n [3.  0.5 3. ]\n [1.  1.  1. ]\n [2.  1.  2. ]\n [3.  0.5 3. ]]\n```\n:::\n\n```{.python .cell-code}\nprint(combo.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(12, 3)\n```\n:::\n\n```{.python .cell-code}\nif __name__ == '__main__':\n    with Pool(processes=2) as pool:\n        # call the same function with different data in parallel\n        for result in pool.imap(map_function, combo):\n            print(1)\n            # report the value to show progress\n            pd_results = pd_results.append(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n```\n:::\n\n```{.python .cell-code}\nprint(pd_results.sort_values('started', ascending=True))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     a    b    c                    started\n0  1.0  1.0  1.0 2023-02-07 18:02:40.146971\n0  2.0  1.0  2.0 2023-02-07 18:02:40.154111\n0  3.0  0.5  3.0 2023-02-07 18:02:41.159027\n0  1.0  1.0  1.0 2023-02-07 18:02:41.164617\n0  2.0  1.0  2.0 2023-02-07 18:02:41.671722\n0  3.0  0.5  3.0 2023-02-07 18:02:42.177044\n0  1.0  1.0  1.0 2023-02-07 18:02:42.678569\n0  2.0  1.0  2.0 2023-02-07 18:02:42.687978\n0  3.0  0.5  3.0 2023-02-07 18:02:43.690178\n0  1.0  1.0  1.0 2023-02-07 18:02:43.696768\n0  2.0  1.0  2.0 2023-02-07 18:02:44.202047\n0  3.0  0.5  3.0 2023-02-07 18:02:44.704862\n```\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}