{"title":"TS - missing data imputation & Smoothing","markdown":{"yaml":{"title":"TS - missing data imputation & Smoothing","tags":["missing data","time series","imputation","python","R"],"categories":["Time Series","Smoothing"],"toc":true},"headingText":"markdown ----","containsRefs":false,"markdown":"\n\n```{r markdown_parameters, include=FALSE}\nknitr::opts_chunk$set(#fig.width=12, \n                      fig.height=4,\n                       out.width = '100%'\n                      ) \nknitr::opts_chunk$set(include =TRUE, #prevents code and results from appearing in the finished file. R Markdown still runs the code in the chunk, and the results can be used by other chunks.\n\n                      warning = FALSE,\n                      message =FALSE,\n                      collapse=TRUE,\n                      error=TRUE\n                      )\noptions(scipen=999)\n```\n\n```{r, include =FALSE}\n\nlibrary(reticulate)\n\nSys.setenv(RETICULATE_PYTHON = \"/Users/lrabalski1/miniforge3/envs/everyday_use/bin/python\")\n\nmyenvs=conda_list()\nenvname=myenvs$name[3]\nuse_condaenv(envname, required = TRUE)\n\n```\n\n```{r, include =FALSE}\ndata_file_path = '/Users/lrabalski1/Desktop/prv/data/'\n```\n\n## Dealing with missing data in Time Series\n\n```{r}\nrequire(zoo)\nrequire(data.table)\nlibrary(dplyr)\nlibrary(lubridate)\n\nunemp <- fread(paste0(data_file_path,\"bezrobocie_USA.csv\")) %>% data.table::melt( id.vars='Year',\n                                                           variable.name = \"months\",\n                                                           value.name='UNRATE') %>% left_join(\n  data.frame(month_nr=c(1:12),\n             months= c(\"Jan\",\"Feb\",\"Mar\",\n                       \"Apr\",\"May\",\"Jun\",\n                       \"Jul\",\"Aug\",\"Sep\",\n                       \"Oct\",\"Nov\",\"Dec\"))\n) %>% mutate(DATE=as_date('0000-01-01',format = '%Y-%m-%d')+years(as.numeric(Year)) + months(month_nr-1)) \n\nhead(unemp)\n\n\nunemp = unemp[, DATE := as.Date(DATE)][!is.na(UNRATE),.(DATE, UNRATE)]\nsetkey(unemp, DATE)\n\n## Creating dataset with random missing values\nrand.unemp.idx <- sample(1:nrow(unemp), .1*nrow(unemp))\nrand.unemp <- unemp[-rand.unemp.idx]\n\n## Creating dataset with systematical missing values, appearing in month with highest unemployment rate\nhigh.unemp.idx <- which(unemp$UNRATE > 8)\nhigh.unemp.idx <- sample(high.unemp.idx, .5 * length(high.unemp.idx))\nbias.unemp <- unemp[-high.unemp.idx]\n\n\n## to identyfy missing data I wil use rolling joins tool from data.table package    \nall.dates <- seq(from = unemp$DATE[1], to = tail(unemp$DATE, 1), by = \"months\")\nrand.unemp = rand.unemp[J(all.dates), roll=FALSE]\nbias.unemp = bias.unemp[J(all.dates), roll=FALSE]\n\n## forward filling\nrand.unemp[, impute.ff := na.locf(UNRATE, na.rm = FALSE)]\nbias.unemp[, impute.ff := na.locf(UNRATE, na.rm = FALSE)]\n\n## Mean moving average with use of lookahead phenomen\nrand.unemp[, impute.rm.lookahead := rollapply(data=c(UNRATE,NA, NA), width=3,\n          FUN= function(x) {\n                         if (!is.na(x[1])) x[1] else mean(x, na.rm = TRUE)\n                         })]         \nbias.unemp[, impute.rm.lookahead := rollapply(c(UNRATE, NA,NA), 3,\n            FUN= function(x) {\n                         if (!is.na(x[1])) x[1] else mean(x, na.rm = TRUE)\n                         })]         \n\n\n\n\n\n## Mean moving average withou use of lookahead phenomen\nrand.unemp[, impute.rm.nolookahead := rollapply(c(NA, NA, UNRATE), 3,\n             function(x) {\n                         if (!is.na(x[3])) x[3] else mean(x, na.rm = TRUE)\n                         })]         \nbias.unemp[, impute.rm.nolookahead := rollapply(c(NA, NA, UNRATE), 3,\n             function(x) {\n                         if (!is.na(x[3])) x[3] else mean(x, na.rm = TRUE)\n                         })]    \n\n\n\n\n\n## linear interpolation fullfilling NA with linear interpolation between two data points\nrand.unemp[, impute.li := na.approx(UNRATE, maxgap=Inf)]\nbias.unemp[, impute.li := na.approx(UNRATE)]\n\nzz <- c(NA, 9, 3, NA, 3, 2,NA,5,6,10,NA,NA,NA,0)\nna.approx(zz, na.rm = FALSE, maxgap=2)\nna.approx(zz, na.rm = FALSE, maxgap=Inf)\nna.approx(zz,xout=11, na.rm = FALSE, maxgap=Inf)\n\n\n\n\n\n## Using root mean square error to compare methods\nprint(rand.unemp[ , lapply(.SD, function(x) mean((x - unemp$UNRATE)^2, na.rm = TRUE)),\n             .SDcols = c(\"impute.ff\", \"impute.rm.nolookahead\", \"impute.rm.lookahead\", \"impute.li\")])\n\nprint(bias.unemp[ , lapply(.SD, function(x) mean((x - unemp$UNRATE)^2, na.rm = TRUE)),\n             .SDcols = c(\"impute.ff\", \"impute.rm.nolookahead\", \"impute.rm.lookahead\", \"impute.li\")])\n\n```\n\n## Metrics\n\n### autocorelation\n\nAutocorelation is measuring the direction of change basing on one point. Since the point on sinusoid close to each other have similar value this autocorelation is high if measuring on distance of pi /6 (0.52). In case of distance of 1 pi value is just opposite so ACF is equal -1.\n\n```{r}\nrequire(data.table)\n## R\nx <- 1:100\ny <- sin(x * pi /6)\nplot(y, type = \"b\")\nacf(y)\n\n## R\ncor(y, shift(y, 1), use = \"pairwise.complete.obs\")\ncor(y, shift(y, 2), use = \"pairwise.complete.obs\") \n```\n\n## Visualisation\n\nAllows for visualising multiple micro time series within dataset. It is called Gant chart,\n\n```{r}\nrequire(timevis)\nrequire(data.table)\ndonations <- fread(paste0(data_file_path,\"donations.csv\"))\nd <- donations[, .(min(timestamp), max(timestamp)), user]\nnames(d) <- c(\"content\", \"start\", \"end\")\nd <- d[start != end]\ntimevis(d[sample(1:nrow(d), 20)])\n```\n\n### partial-autocorelation\n\nPartial autocorelation shows which point have informational meaning and which simple derives from harmonical periods of time. For seasonal, wihtout noise process, PACF show which correlation for given delay, are the true ones, eliminating redunduntion.It helps to aproximate how much data do we need to poses to apply sufficient window for given time scale.\n\n```{r}\n## R\ny <- sin(x * pi /6)\nplot(y[1:30], type = \"b\") \npacf(y)\n\n```\n\n## Simulation\n\n## Smoothing\n\nSmoothing is commonelly used forecasting method. Smoothed time series can be used as zero hypothesis to for testing more sophisticated methods.\n\n```{python}\nimport pandas as pd\nimport numpy as np\nimport datetime\n\nunemp = r.unemp\n#unemp.index = unemp.DATE\n\ndf = unemp.copy()\ndf = df[((df.DATE >=pd.to_datetime('2014-01-01')) & (df.DATE < pd.to_datetime('2019-01-01')))]\ndf = df.rename(columns={\"UNRATE\": \"data\"})\n#df.reset_index(drop=True, inplace=True)\n\n\ntrain = df[['data']].iloc[:-12, :]\ntest = df[['data']].iloc[-12:, :]\n# train.index = pd.to_datetime(train.index)\n# test.index = pd.to_datetime(test.index)\n## We can use the pandas.DataFrame.ewm() function to calculate the exponentially weighted moving average for a certain number of previous periods.\n```\n\n### moving average\n\nAn improvement over simple average is the average of n last points. Obviously the thinking here is that only the recent values matter. Calculation of the moving average involves what is sometimes called a \"sliding window\" of size n:\n\n```{python}\n\ndef average(series):\n    return float(sum(series))/len(series)\n\n# moving average using n last points\ndef moving_average(series, n):\n    return average(series[-n:])\n\nmoving_average(train.data,4)\n```\n\n### Weighted Moving Average\n\nA weighted moving average is a moving average where within the sliding window values are given different weights, typically so that more recent points matter more.\n\nInstead of selecting a window size, it requires a list of weights ([**which should add up to 1**]{.underline}). For example if we picked \\[0.1, 0.2, 0.3, 0.4\\] as weights, we would be giving 10%, 20%, 30% and 40% to the last 4 points respectively. In Python:\n\n```{python}\n# weighted average, weights is a list of weights\ndef weighted_average(series, weights):\n    result = 0.0\n    weights.reverse()\n    for n in range(len(weights)):\n        result += series[-n-1] * weights[n]\n    return result\n  \nweights = [0.1, 0.15, 0.25, 0.5]\nweighted_average(train.data.values, weights)\n\n\n```\n\n### exponentially weightening\n\nThe exponentially weighted function is calculated recursively:\n\n$$\\begin{split}\\begin{split}\ny_0 &= x_0\\\\\ny_t &= \\alpha x_t + (1 - \\alpha) y_{t-1} ,\n\\end{split}\\end{split}$$\n\nwhere alpha is smoothing factor $0 < \\alpha \\leq 1$ . The higher the Î±, the faster the method \"forgets\".\n\nThere is an aspect of this method that programmers would appreciate that is of no concern to mathematicians: it's simple and efficient to implement. Here is some Python. Unlike the previous examples, this function returns expected values for the whole series, not just one point.\n\n```{python}\n# given a series and alpha, return series of smoothed points\ndef exponential_smoothing(series, alpha):\n    result = [series[0]] # first value is same as series\n    for n in range(1, len(series)):\n        result.append(alpha * series[n] + (1 - alpha) * result[n-1])\n    return result\n\n\nres_exp_smooth8 = exponential_smoothing(train.data.values, alpha=0.8)\nres_exp_smooth5 = exponential_smoothing(train.data.values, alpha=0.5)\nres_exp_smooth2 = exponential_smoothing(train.data.values, alpha=0.2)\n\n\n\n\n```\n\n```{python, eval=FALSE, include=FALSE}\n\nUsing Pandas.\n\nWhen adjust=False, the exponentially weighted function is calculated recursively\n\nThe higher is alpha the lower impact of the most fresh data\n\nunemp['Smooth.1'] = unemp.UNRATE.ewm(alpha=0.1,adjust=False,).mean()\nunemp['Smooth.2'] = unemp.UNRATE.ewm(alpha=0.2,adjust=False).mean()\n\nunemp['Smooth.3'] = unemp.UNRATE.ewm(alpha=0.3,adjust=False,).mean()\n\nimport matplotlib.pyplot as plt\n\nplt.clf()\nplt.plot(unemp['UNRATE'], label='raw')\nplt.plot(unemp['Smooth.1'], label='Smooth.1')\nplt.plot(unemp['Smooth.2'], label='Smooth.2')\nplt.plot(unemp['Smooth.3'], label='Smooth.3')\nplt.xlim([datetime.date(2015, 1, 1), datetime.date(2020, 1, 1)])\nplt.legend(loc=2)\nplt.show()\n\n```\n\n```{python, eval=FALSE, include=FALSE}\nimport pandas as pd\nimport json\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\nfrom statsmodels.tsa.holtwinters import SimpleExpSmoothing, Holt\n\n\npred = test.copy()\n\nmodel = SimpleExpSmoothing(np.asarray(train['data']))\n#model._index = pd.to_datetime(train.index)\n\nfit1 = model.fit()\n\npred1 = fit1.forecast(10)\nfit2 = model.fit(smoothing_level=.2)\npred2 = fit2.forecast(10)\nfit3 = model.fit(smoothing_level=.5)\npred3 = fit3.forecast(10)\n\nfig, ax = plt.subplots(figsize=(12, 6))\nax.plot(train.index, train.values)\nax.plot(test.index, test.values, color=\"gray\")\nfor p, f, c in zip((pred1, pred2, pred3),(fit1, fit2, fit3),('#ff7823','#3c763d','c')):\n    ax.plot(train.index, f.fittedvalues, color=c)\n    ax.plot(test.index, p, label=\"alpha=\"+str(f.params['smoothing_level'])[:3], color=c)\nplt.title(\"Simple Exponential Smoothing\")    \nplt.legend();\nplt.show()    \n\n\n```\n\n### Conclusion\n\nI showed some basic forecasting methods: moving average, weighted moving average and, finally, single exponential smoothing. One very important characteristic of all of the above methods is that remarkably, they can only forecast a single point. That's correct, just one.\n\n### Double exponential smoothing\n\na.k.a Holt Method\n\nIn case of forecasting simple exponential weightening isn't giving good results for data posessing longterm trend. For this purpose it is good to apply method aimed for data with trend (Holt) or with trend and seasonality (Holt-Winter).\n\nDouble exponential smoothing is nothing more than exponential smoothing applied to both level and trend.\n\n```{python}\n\n# given a series and alpha, return series of smoothed points\ndef double_exponential_smoothing(series, alpha, beta):\n    result = [series[0]]\n    for n in range(1, len(series)+1):\n        if n == 1:\n            level, trend = series[0], series[1] - series[0]\n        if n >= len(series): # we are forecasting\n          value = result[-1]\n        else:\n          value = series[n]\n        last_level= level\n        level =  alpha*value + (1-alpha)*(last_level+trend)\n        trend = beta*(level-last_level) + (1-beta)*trend\n        result.append(level+trend)\n    return result\n\n\nres_double_exp_smooth_alpha_9_beta9=double_exponential_smoothing(train.data.values, alpha=0.9, beta=0.9)\n\n```\n\n### Triple Exponential Smoothing\n\na.k.a Holt-Winters Method\n\n#### Initial Trend\n\nFor double exponential smoothing we simply used the first two points for the initial trend. With seasonal data we can do better than that, since we can observe many seasons and can extrapolate a better starting trend. The most common practice is to compute the average of trend averages across seasons.\n\n```{python}\n\ndef initial_trend(series, slen):\n    sum = 0.0\n    for i in range(slen):\n        sum += float(series[i+slen] - series[i]) / slen\n    return sum / slen\n\nres_initial = initial_trend(train.data.values,12)\nres_initial\n```\n\nThe value of `r round(py$res_initial,3)` can be interpreted that unemployment rate between first two years change on average by `r round(py$res_initial,3)` between each pair of the same month.\n\n#### Initial Seasonal Components\n\nThe situation is even more complicated when it comes to initial values for the seasonal components. Briefly, we need to\n\n1.  compute the average level for every observed season (in our case YEAR) we have,\n\n2.  divide every observed value by the average for the season it's in\n\n3.  and finally average each of these numbers across our observed seasons.\n\n```{python}\ndef initial_seasonal_components(series, slen):\n    seasonals = {}\n    season_averages = []\n    n_seasons = int(len(series)/slen)\n    # compute season averages\n    for j in range(n_seasons):\n        season_averages.append(sum(series[slen*j:slen*j+slen])/float(slen))\n    # compute initial values\n    for i in range(slen):\n        sum_of_vals_over_avg = 0.0\n        for j in range(n_seasons):\n            sum_of_vals_over_avg += series[slen*j+i]-season_averages[j]\n        seasonals[i] = sum_of_vals_over_avg/n_seasons\n    return seasonals\n\ninitial_seasonal_components(train.data.values,12)\n\n```\n\nSeasonal values we can interpret as average distance value from seasonal average. We can see that January {0} is on higher than average and December value {11} is lower than average. We can see that those month differ from each other exactly with the power of those values\n\n```{python}\ndf[pd.to_datetime(df.DATE).dt.month.isin([1,12])]\n```\n\n```{python}\ndef triple_exponential_smoothing(series, slen, alpha, beta, gamma, n_preds):\n    result = []\n    seasonals = initial_seasonal_components(series, slen)\n    for i in range(len(series)+n_preds):\n        if i == 0: # initial values\n            smooth = series[0]\n            trend = initial_trend(series, slen)\n            result.append(series[0])\n            continue\n        if i >= len(series): # we are forecasting\n            m = i - len(series) + 1\n            result.append((smooth + m*trend) + seasonals[i%slen])\n        else:\n            val = series[i]\n            last_smooth, smooth = smooth, alpha*(val-seasonals[i%slen]) + (1-alpha)*(smooth+trend)\n            trend = beta * (smooth-last_smooth) + (1-beta)*trend\n            seasonals[i%slen] = gamma*(val-smooth) + (1-gamma)*seasonals[i%slen]\n            result.append(smooth+trend+seasonals[i%slen])\n    return result\n\nres_triple_exp_smooth = triple_exponential_smoothing(train.data.values, 12, 0.7, 0.02, 0.9, 10)\n\n```\n\nA Note on Î±, Î² and Î³\n\nYou may be wondering from where values 0.7, 0.02 and 0.9 for Î±, Î² and Î³ It was done by way of trial and error: simply running the algorithm over and over again and selecting the values that give you the smallest SSE. This process is known as fitting.\n\nThere are more efficient methods at zooming in on best values. One good algorithm for this is Nelder-Mead, which is what tgres uses.\n\n### fitting data\n\n```{python}\nres = [res_exp_smooth8,res_exp_smooth5,res_exp_smooth2,res_double_exp_smooth_alpha_9_beta9,res_triple_exp_smooth]\nRMSE = []\ni=1\nfor i in range(len(res)):\n  RMSE.append(np.sqrt(np.mean(np.square((train.data.values[0:48]- res[i][0:48])))))\nRMSE\n\n```\n\nIn case of fitting smoothed data to raw data, the best fit possess single exponenetial smoothing method with **alpha =0.8** (putting higher weight on most recent data). This is exactly what could be expected. Is it then the best **forecasting method** for my data?\n\nObviously not.\n\nSince all method take data point from time *t* for estimating smoothed value for time *t* such a models are not forecasting one's. We are dealing here with **lookahead** problem. In order to predict we are using data which shouldn't be available at the moment of making prediction.\n\nOut of three methods prediction capabilities posses Holt method (using trend to linearly predict further data points) and Holt-Winter method (using trend and seasonality to predict further data points).\n\n### plot\n\n```{python}\nimport matplotlib.pyplot as plt\nimport datetime\nplt.style.use('Solarize_Light2')\n\n   \nplt.clf()\nfig = plt.figure(figsize=(5,8))\n# f.set_figwidth(10)#inches\n# f.set_figheight(20)#inches\nax1 = fig.add_subplot(5, 1, 1) \nplt.plot(train.data.values, label='raw')\nplt.plot(res_exp_smooth8, label='exp_smooth_alpha_0.8')\nax2 =fig.add_subplot(5, 1, 2)\nplt.plot(train.data.values, label='raw')\nplt.plot(res_exp_smooth5, label='exp_smooth_alpha_0.5')\nax3 =fig.add_subplot(5, 1, 3)\nplt.plot(train.data.values, label='raw')\nplt.plot(res_exp_smooth2, label='exp_smooth_alpha_0.2')\nax4 =fig.add_subplot(5, 1, 4)\nplt.plot(train.data.values, label='raw')\nplt.plot(res_double_exp_smooth_alpha_9_beta9, label='res_double_exp_smooth_alpha_9_beta9')\nax5 =fig.add_subplot(5, 1, 5)\nplt.plot(train.data.values, label='raw')\nplt.plot(res_triple_exp_smooth, label='res_triple_exp_smooth')\nax1.set_title('raw data vs exponential forecast')\nax1.legend(loc=\"upper left\")\nax2.legend(loc=\"upper left\")\nax3.legend(loc=\"upper left\")\nax4.legend(loc=\"upper left\")\nax5.legend(loc=\"upper left\")\nax1.sharex(ax5)\nax2.sharex(ax5)\nax3.sharex(ax5)\nax4.sharex(ax5)\n\nfig.tight_layout()\nfig.savefig('index_files/figure-html/unnamed-chunk-15-1.png', bbox_inches='tight')\n\nplt.show()\n\n\n```\n\n## regression\n\n### autoregression models\n\nAs name suggest autoregression is regression made upon past values. The simplest autoregression model is known as AR(1): $y_t=b_0+b_1*y_{t-1}+e_t$ $e_t$ is changeable within time error with stable variance and mean = 0.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"highlight-style":"github","toc":true,"output-file":"index.html"},"language":{"code-summary":"Show the code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.269","editor":"source","theme":"darkly","title-block-banner":true,"code-copy":true,"code-block-border-left":"#31BAE9","title":"TS - missing data imputation & Smoothing","tags":["missing data","time series","imputation","python","R"],"categories":["Time Series","Smoothing"]},"extensions":{"book":{"multiFile":true}}}}}