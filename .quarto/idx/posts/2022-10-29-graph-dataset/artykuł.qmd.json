{"title":"DGL graph datastructure","markdown":{"yaml":{"title":"DGL graph datastructure","date":"2022-10-28","categories":["DGL"],"tags":["DGL","graph","graph datastructure","compressed sparsed matrix"],"toc":true},"headingText":"[url](https://www.jianshu.com/p/767950b560c4)","containsRefs":false,"markdown":"\n\n```{r include=FALSE}\n```\n\n```{r include =FALSE}\nknitr::opts_chunk$set(#fig.width=12, \n                      fig.height=4,\n                       out.width = '100%'\n                      ) \nknitr::opts_chunk$set(include =TRUE, #When `include = FALSE`, this whole code chunk is excluded in the output, but note that it will still be evaluated if `eval = TRUE`. When you are trying to set `echo = FALSE`, `results = 'hide'`, `warning = FALSE`, and `message = FALSE`, chances are you simply mean a single option `include = FALSE` instead of suppressing different types of text output individually.\n                      warning = FALSE,\n                      message =FALSE,\n                      collapse=TRUE,\n                      error=TRUE\n                      )\noptions(scipen=999)\n```\n\n```{r, include =FALSE}\n\nlibrary(reticulate)\nmyenvs=conda_list()\nenvname=myenvs$name[5]\nuse_condaenv(envname, required = TRUE)\n```\n\n```{python, include =FALSE}\ndata_file_path= '/Users/lrabalski1/Desktop/prv/data/'\nrepo_directory = '/Users/lrabalski1/Desktop/Mrowisko/000Pracownicy/000_Rabalski_Lukasz/2022.05.19 graf/repo projektu/graph-recommendator/pinsage/'\n```\n\n# Creating Graph data\n\nVery simple example below\n\n```{python}\n# Each value of the dictionary is a list of edge tuples.\n# Nodes are integer IDs starting from zero. Nodes IDs of different types have\n# separate countings.\nimport torch\nimport dgl\n\nratings = dgl.heterograph(\n    {('user', '+1', 'movie') : [(0, 0), (0, 1), (1, 0)],\n     ('user', '-1', 'movie') : [(2, 1)]})\nratings\n\n\n```\n\n## saving graph\n\nIn order to save graph as object, very convenient method is to use `pickle.`\n\n```{python, eval=FALSE}\nimport pickle\n\noutput_file = 'builded_graph.pkl'\ndirectory = 'input/'\nwith open(directory + output_file, 'rb') as f:\n    g = pickle.load(f)\n\n\n#loading saved graph\nwith open(directory  + output_file, 'rb') as f:\n    sp_matrix = pickle.load(f)\n\n```\n\nTo create a more realistic heterograph let's use the ACM dataset. \\## Graphs Dataset can be downloaded from [here](https://www.aminer.org/citation). It's stored in mat (matrix) object. Within which we can find object/matrices stored in a `compresed sparsed` format. More about further.\n\n```{python}\nimport scipy.io\nimport urllib.request\n\ndata = scipy.io.loadmat(data_file_path+'ACM.mat')\n\n\n```\n\n## compresed sparsed matrix\n\nMany different ways to store `sparsed matrices` may be find in scipy [documentation](https://docs.scipy.org/doc/scipy/reference/sparse.html).\n\nFor us most important will be `csr_matrix` and `csc_matrix`.\n\nCSC format is almost identical, except that values are indexed first by column with a column-major order. Usually, the CSC is used when there are more rows than columns. On the contrary, the CSR works better for a 'wide' format. So, her is taking CSR as an example here.\n\nBelow short example how `sparsed matrices` can be handle with `scipy` package.\n\n```{python}\nimport numpy as np\nfrom scipy.sparse import csr_matrix, csc_matrix\narr = np.array([[0, 0, 0], [0, 0, 1], [1, 2, 0]])\n\narr_csr = csr_matrix(arr)\narr_csc = csc_matrix(arr)\n\nprint(type(arr_csr))\nprint(type(arr_csc))\n\n# `CSC` format is almost identical, except that values are indexed first by column with a column-major order. Usually, the `CSC` is used when there are more rows than columns. On the contrary, the `CSR` works better for a ‘wide’ format. So, her is taking CSR as an example here\nprint(arr_csr)\nprint(arr_csc)\n\n# however in order to get access ti those indexes need to use method to_coo.\narr_csr.tocoo().row\narr_csr.tocoo().col\n\n#Viewing stored data (not the zero items) with the data property\nprint(arr_csr.data)\nprint(arr_csc.data)\n\n#Counting nonzeros with the count_nonzero() method:\nprint(arr_csr.count_nonzero())\nprint(arr_csc.count_nonzero)\n\nprint(arr_csr.toarray())\nprint(arr_csc.todense())\n\n\n```\n\n## SP matrix methods\n\n### bipartite_from_scipy\n\n```{python}\nimport scipy.sparse as sp\n\nsp_matrix = data['PvsA']\nprint(type(sp_matrix))\n\nprint('#Papers:', sp_matrix.shape[0])\nprint('#Authors:',sp_matrix.shape[1])\nprint('#Links:', sp_matrix.nnz)\n\n# ways of populating graph with coo_matrix\n\npp_g = dgl.bipartite_from_scipy(sp_matrix, utype='paper', etype='written-by', vtype='author')\n\npp_g.is_homogeneous\nprint(pp_g.number_of_nodes())\nprint(pp_g.number_of_edges())\nprint(pp_g.successors(3))\n\nprint('Node types:', pp_g.ntypes)\nprint('Edge types:', pp_g.etypes)\nprint('Canonical edge types:', pp_g.canonical_etypes)\n\n```\n\nIn order to visualize the interactions (edges) between nodes let use following function.\n\n```{python}\nimport pygraphviz as pgv\ndef plot_graph(nxg, plot_name):\n    ag = pgv.AGraph(strict=False, directed=True)\n    for u, v, k in nxg.edges(keys=True):\n        ag.add_edge(u, v, label=k)\n    ag.layout('dot')\n    ag.draw(plot_name+'.png')\n\n```\n\n```{python}\nplot_graph(nxg=pp_g.metagraph(),plot_name='simple_graph')\n```\n\n![](simple_graph.png)\n\n### heterograph\n\nUsing ACM dataset\n\n```{python}\nimport torch\n\n# Unfortunately following code no longer works\nG = dgl.heterograph({\n        ('paper', 'written-by', 'author') : data['PvsA'],\n        ('author', 'writing', 'paper') : data['PvsA'].transpose(),\n        ('paper', 'citing', 'paper') : data['PvsP'],\n        ('paper', 'cited', 'paper') : data['PvsP'].transpose(),\n        ('paper', 'is-about', 'subject') : data['PvsL'],\n        ('subject', 'has', 'paper') : data['PvsL'].transpose(),\n    })\n\n# we need to a little bit tweak the code the get the same result as above.\nG = dgl.heterograph({\n        ('paper', 'written-by', 'author') : \n          (torch.tensor(data['PvsA'].tocoo().col),torch.tensor(data['PvsA'].tocoo().row )),\n         ('author', 'writing', 'paper') : \n           (torch.tensor(data['PvsA'].tocoo().row) ,torch.tensor(data['PvsA'].tocoo().col)),\n        ('paper', 'citing', 'paper') : \n          (torch.tensor(data['PvsP'].tocoo().col),torch.tensor(data['PvsP'].tocoo().row )),\n        ('paper', 'cited', 'paper') : \n          (torch.tensor(data['PvsP'].tocoo().row) ,torch.tensor(data['PvsP'].tocoo().col)),\n        ('paper', 'is-about', 'subject') : \n          (torch.tensor(data['PvsL'].tocoo().col),torch.tensor(data['PvsL'].tocoo().row )),\n        ('subject', 'has', 'paper') : \n          (torch.tensor(data['PvsL'].tocoo().row) ,torch.tensor(data['PvsL'].tocoo().col))\n    })\n  \nplot_graph(nxg=G.metagraph(),plot_name='more_complicated_graph')\n\n\n\n```\n\n![](more_complicated_graph.png)\n\n## pandas method\n\nOn [github repository](https://github.com/yoonjong12/pinsage/blob/main/builder.py) we can find a method allowing for building graphs using pandas dataphrame.\n\n```{python}\nimport numpy as np\nimport pandas as pd\nimport sys\nsys.path.insert(1, repo_directory)\nfrom builder import PandasGraphBuilder\n\nusers=pd.DataFrame(data=range(1,101), columns=['user_id'])\nproducts=pd.DataFrame(data=range(1,50), columns=['product_id'])\ninteractions=pd.DataFrame(data={\n  'user_id': np.random.choice(users.user_id,1000,replace=True),\n  'product_id' :np.random.choice(products.product_id,1000,replace=True)}\n  )\n\n\n\n\ngraph_builder = PandasGraphBuilder()\ngraph_builder.add_entities(users, 'user_id', 'user')\ngraph_builder.add_entities(products, 'product_id', 'product')\n\ngraph_builder.add_binary_relations(interactions, 'user_id','product_id', 'interaction')\ngraph_builder.add_binary_relations(interactions, 'product_id','user_id', 'interaction-by')\n\nprint('starting graph building')\ng = graph_builder.build()\n\nplot_graph(nxg=g.metagraph(),plot_name='pandas_graph')\n\n```\n\n![](pandas_graph.png)\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"highlight-style":"github","toc":true,"output-file":"artykuł.html"},"language":{"code-summary":"Show the code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.269","editor":"source","theme":"darkly","title-block-banner":true,"code-copy":true,"code-block-border-left":"#31BAE9","title":"DGL graph datastructure","date":"2022-10-28","categories":["DGL"],"tags":["DGL","graph","graph datastructure","compressed sparsed matrix"]},"extensions":{"book":{"multiFile":true}}}}}