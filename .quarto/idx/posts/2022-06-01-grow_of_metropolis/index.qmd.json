{"title":"Grow of Metropolis","markdown":{"yaml":{"title":"Grow of Metropolis","categories":["Python"],"tags":["python","geocoding"],"date":"2022-10-25"},"headingText":"About","containsRefs":false,"markdown":"\n\n\nAims:\n\n1.  FIlter out the data localisation where people are supposed to live in (cities; villages etc)\n\n2.  Select cities which are metropolis based on population on external source\n\n3.  Write a script which will ascribe metropolis to a city. Additionally model a process of consecutive cities which would be ascribed to the city bearing in mind that city will grow thanks to this process.\n\n[Data Source](http://www.geonames.org/)\n\n[Documentation](http://www.geonames.org/export/codes.html)\n\n## Preparing environment\n\nSetting default markdown option responsible of code chunk behaviour.\n\n```{r markdown_parameters, include=FALSE}\n#markdown ----\nknitr::opts_chunk$set(#fig.width=12, \n                      fig.height=4,\n                       out.width = '100%'\n                      ) \nknitr::opts_chunk$set(include =TRUE, \n                      warning = FALSE,\n                      message =FALSE,\n                      collapse=TRUE\n)\noptions(scipen=999)\n```\n\nFirstly I choose prefered python environment on which I have installed useful libraries.\n\n```{r}\nlibrary(reticulate)\nmyenvs=conda_list()\nenvname=myenvs$name[3]\nuse_condaenv(envname, required = TRUE)\n\nSys.setenv(RETICULATE_PYTHON = \"/Users/lrabalski1/miniforge3/envs/everyday_use/bin/python\")\nreticulate::py_config()\n```\n\n```{python, include=FALSE}\nfile_path_name='/Users/lrabalski1/Desktop/prv/data/geonames_org.csv'\n```\n\n```{python, include=FALSE}\nimport pandas as pd\nimport numpy as np\nimport mpu\nimport geopy.distance\n```\n\nBellow I present two function:\n\n-   radius - function which based on city population is calculating a radius within which city is able to absorb cities from this range\n\n-   \\_calcualate_metrocity_impact - calculate impact on metrocity on given city\n\n```{python}\ndef radius(population):\n    METRO_CITY_POPULATION_CONSTANT = -1/1443000\n    MIN_METRO_CITY_RADIUS = 10\n    MAX_METRO_CITY_RADIUS = 100 - MIN_METRO_CITY_RADIUS\n    return MIN_METRO_CITY_RADIUS + MAX_METRO_CITY_RADIUS * (1 - np.exp(METRO_CITY_POPULATION_CONSTANT *  population))\n\ndef _calcualate_metrocity_impact(max_radius, distance_to_metro_city):\n    METRO_CITY_POWER_CONSTANT = -1.4\n    impact = np.exp(METRO_CITY_POWER_CONSTANT  * distance_to_metro_city / max_radius)\n    return impact\n```\n\nFunction responsible for calculating distances between 2 points on earth surface.\n\n```{python}\n#https://towardsdatascience.com/heres-how-to-calculate-distance-between-2-geolocations-in-python-93ecab5bbba4\ndef haversine_distance_code(lat1, lon1, lat2, lon2):\n    r = 6371\n    phi1 = np.radians(lat1)\n    phi2 = np.radians(lat2)\n    delta_phi = np.radians(lat2 - lat1)\n    delta_lambda = np.radians(lon2 - lon1)\n    a = np.sin(delta_phi / 2)**2 + np.cos(phi1) * np.cos(phi2) *   np.sin(delta_lambda / 2)**2\n    res = r * (2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a)))\n    return np.round(res, 2)\n```\n\n```{python}\ndf= pd.read_csv(file_path_name, sep=\"\\t\", \n                names=['geonameid','name','asciiname','alternatenames','latitude','longitude','feature class','feature code','country code','cc2','admin1 code','admin2 code','admin3 code','admin4 code','population','elevation','dem','timezone','modification date',])\n\n\n```\n\nDataset readme states that column feature classes contains level information of:\n\nA: country, state, region,...\n\nH: stream, lake, ...\n\nL: parks,area, ...\n\nP: city, village,...\n\nR: road, railroad\n\nS: spot, building, farm\n\nT: mountain,hill,rock,...\n\nU: undersea\n\nV: forest,heath,...\n\nWe will be interested on object of level P, and maybe A.\n\n```{python}\nimport requests\n\nurl = 'http://www.geonames.org/export/codes.html'\nhtml = requests.get(url).content\ndf_list = pd.read_html(html)\ndf_legend = df_list[-1]\ndf_legend = df_legend.rename(columns={df_legend.columns[0]: 'feature code',\n                                     df_legend.columns[1]: 'short  descr',\n                                     df_legend.columns[2]: 'long descr'})\ndf_legend = pd.merge(df[['feature code','feature class']].drop_duplicates(),df_legend, on='feature code')\ndf_legend\n```\n\n```{python, results='hide'}\ndf = df[df['feature class'].isin(['P','A'])]\ndf_check = pd.merge(df,df_legend, on=['feature code','feature class'])\n\n# sorting by the biggest objects I can see that those are cities\ndf_check[df_check['feature class']=='P'].sort_values('population', ascending=False).head(5)\n\n# administrative object located in object of level P\ndf_check[df_check['feature class']=='A'].sort_values('population', ascending=False).head(5)\n\n#z tej tabeli wynika, ze PPLX to sekcje zaludnionych miejsc, sa to ulice, dzielnice, wiec wykluczam, sa czescia miast\ndf_check[['feature class','feature code', 'short  descr']].drop_duplicates()\n\n#finalnie musze skupic sie na na obu klasach, jednoczesnie usuwajac duplikaty\ndf = df[(df['feature class'].isin(['P'])) & \n        (df.population != 0) & \n        ~(df['feature code'].isin(['PPLX']))].drop_duplicates('name')\n\n\ndf.index.name = 'city_id'\ndf.reset_index(inplace=True)\n```\n\n```{python}\ndf.groupby(['feature class','feature code']).agg({'population': ['mean', 'min', 'max']})\n```\n\n## Metropolis in Poland\n\n[wikipedia](https://pl.wikipedia.org/wiki/Obszar_metropolitalny) Warszawa, Katowice, Kraków, Łódź, Trójmiasto, Poznań, Wrocław, Bydgoszcz, Szczecin, Lublin.\n\n```{python}\ndf_metropolie = df[df.name.isin(\n    ['Warsaw','Katowice','Kraków','Łódź',\n     'Gdańsk','Gdynia',#'Trójmiasto',\n     'Poznań','Wrocław','Bydgoszcz','Szczecin','Lublin'])][\n    ['city_id','name','population','latitude','longitude']]\ndf_metropolie['iteration']=0 \n#df_metropolie['radius'] = radius(df_metropolie['population'])\ndf_metropolie=df_metropolie.add_suffix('_metro')\ndf_metropolie\n```\n\n## metropolis absorption algorithm\n\n### Instruction\n\n1.  stworze id kolumne z indeksem\n\n2.  zlacze tabele z metropoliami i wszystkimi miastami im do tej pory przypisanymi, wylicze zagregowana ludnosc oraz promien metropoli\n\n3.  croos joinuje do kazdego miasta bez przypisanej metropolii tabele z metropolia\n\n4.  wylicze odleglosc miejscowosci od metropoli i pozbede sie tych wierszy ktore sa poza promieniem\n\n5.  dla pozostalych miejscowosci wylicze moc metropolii\n\n6.  zrobie slice max groupujac po id miejscowosci pozostawiajc metropolie wchlaniajaca - tak powstanie tabela incrementalna do ktorej potem bede rbindowal nastepne tego typu tabele\n\n7.  w obu tabelach powstanie tabele z indeksem mowiacy o n-iteracji z jakiej pochodzi przypisanie miejscowosci do metropolii oraz stan populacji\n\n8.  wszystko zamkne w lupie while ktory bedzie wykonywany tak dlugo jak zostanie odnotowany przyrost w tabeli incrementalnej\n\n```{python}\ndf_cities = df[['city_id','name','population','latitude','longitude']]\ndf_cities = df_cities.loc[~df_cities.city_id.isin(df_metropolie.city_id_metro)]\ndf_cities.head(5)\n```\n\n### wlasciwy algorytm\n\n```{python}\ndf_miasta_w_puli =df_cities\ncolumn_names = ['city_id','name','population'] +df_metropolie.columns.values.tolist()\ndf_miasta_wchloniete=pd.DataFrame(columns=column_names)\nstart = True\niteration =0\n\n\n# start funkcji\nwhile start == True:\n    df_metropolie_powiekszone=df_metropolie.append(df_miasta_wchloniete, ignore_index=True)\n    df_metropolie_powiekszone.population = df_metropolie_powiekszone.population.combine_first(df_metropolie_powiekszone.population_metro)\n    \n    df_metropolie_powiekszone_popul = df_metropolie_powiekszone.groupby(\n        ['city_id_metro','name_metro','population_metro','latitude_metro','longitude_metro',]).agg(\n        {'population':['sum']}).reset_index()\n    df_metropolie_powiekszone_popul.columns = df_metropolie_powiekszone_popul.columns.droplevel(1)\n    df_metropolie_powiekszone_popul['radius'] = radius(df_metropolie_powiekszone_popul['population'])\n    df_miasta_w_puli['key'] = 1\n    df_metropolie_powiekszone_popul['key'] = 1\n    df_x = pd.merge(df_miasta_w_puli, df_metropolie_powiekszone_popul, on='key', suffixes=('','_y')).drop(\"key\", 1)\n    #calculating distance between two coordinates \n    #https://stackoverflow.com/questions/19412462/getting-distance-between-two-points-based-on-latitude-longitude\n    distances_km = []\n    for row in df_x.itertuples():\n        distances_km.append(\n            haversine_distance_code( row.latitude, row.longitude ,row.latitude_metro, row.longitude_metro)\n        )\n    df_x['distance_km'] = distances_km\n    df_x = df_x[df_x.radius >= df_x.distance_km]\n    df_x['impact'] = _calcualate_metrocity_impact(df_x.radius,df_x.distance_km)\n    #stwierdzam do ktorej finalnie metropoli miejscowosci zostaje zaliczon\n    idx = df_x.groupby(['name','population'])['impact'].transform(max) == df_x['impact']\n    df_x = df_x[idx]\n    iteration+= 1\n    df_x['iteration_metro']=iteration\n    pre_rows_num=df_miasta_wchloniete.shape[0]\n    df_miasta_wchloniete=df_miasta_wchloniete.append(\n        df_x[column_names], ignore_index=True)\n    #pozbywam sie miast juz wchlonietych\n    indx = df_miasta_w_puli.city_id.isin(df_miasta_wchloniete.city_id)\n    df_miasta_w_puli = df_miasta_w_puli[~indx]\n    if pre_rows_num == df_miasta_wchloniete.shape[0]:\n        start = False\n\ndf_metropolie_powiekszone_popul = df_metropolie_powiekszone.groupby(\n    ['city_id_metro','name_metro','population_metro','latitude_metro','longitude_metro',]).agg(\n    {'population':['sum']}).reset_index()\ndf_metropolie_powiekszone_popul.columns = df_metropolie_powiekszone_popul.columns.droplevel(1)\ndf_metropolie_powiekszone_popul['radius'] = radius(df_metropolie_powiekszone_popul['population'])\n\n\n```\n\n```{python}\n#finalne populacje metropoli\ndf_metropolie_powiekszone_popul.head(5)\n\n#przypisanie miast do metropoli wraz numerem iteracji\ndf_miasta_wchloniete.head(5)\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"highlight-style":"github","output-file":"index.html"},"language":{"code-summary":"Show the code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.269","editor":"source","theme":"darkly","title-block-banner":true,"code-copy":true,"code-block-border-left":"#31BAE9","title":"Grow of Metropolis","categories":["Python"],"tags":["python","geocoding"],"date":"2022-10-25"},"extensions":{"book":{"multiFile":true}}}}}